<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>贪吃蛇</title>
  <style>
    :root {
      color-scheme: light dark;
      --bg0: #070a10;
      --bg1: #0b1320;
      --card: rgba(255,255,255,.06);
      --stroke: rgba(255,255,255,.12);
      --text: #e8eef5;
      --muted: rgba(232,238,245,.78);
      --accent: #66e0ff;
      --accent2: #66ffb2;
      --food: #ffcc66;
    }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "PingFang SC", "Noto Sans CJK SC", "Microsoft YaHei", sans-serif;
      display: grid;
      place-items: center;
      min-height: 100vh;
      background:
        radial-gradient(1200px 900px at 15% 10%, rgba(102,224,255,.14), transparent 55%),
        radial-gradient(900px 700px at 90% 30%, rgba(102,255,178,.10), transparent 55%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      color: var(--text);
    }
    .wrap {
      width: min(92vw, 560px);
      padding: 16px;
      box-sizing: border-box;
    }
    h1 { font-size: 18px; margin: 0 0 8px; font-weight: 750; letter-spacing: .2px; }
    .sub { font-size: 13px; color: var(--muted); margin: 0 0 12px; line-height: 1.45; }

    .panel {
      background: var(--card);
      border: 1px solid var(--stroke);
      border-radius: 16px;
      padding: 12px;
      box-shadow: 0 12px 40px rgba(0,0,0,.35);
    }

    canvas {
      width: 100%;
      height: auto;
      background: linear-gradient(180deg, rgba(15,22,32,1), rgba(10,14,22,1));
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      touch-action: none;
      display: block;
    }

    .bar {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      margin-top: 10px;
      flex-wrap: wrap;
    }

    .pill {
      padding: 8px 10px;
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 999px;
      font-size: 13px;
      background: rgba(255,255,255,.06);
      backdrop-filter: blur(8px);
    }

    button {
      appearance: none;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.10);
      color: inherit;
      padding: 10px 12px;
      border-radius: 12px;
      font-size: 14px;
      font-weight: 750;
      transition: transform .06s ease, background .12s ease;
    }
    button:hover { background: rgba(255,255,255,.14); }
    button:active { transform: translateY(1px) scale(.99); }

    .controls {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 8px;
      margin-top: 12px;
      user-select: none;
    }
    .controls button {
      padding: 14px 0;
      font-size: 16px;
      border-radius: 14px;
      background: rgba(255,255,255,.10);
    }
    .controls .spacer { visibility: hidden; }

    .footer { margin-top: 10px; font-size: 12px; color: rgba(232,238,245,.7); }

    .overlay {
      position: fixed;
      inset: 0;
      display: none;
      place-items: center;
      background: rgba(0,0,0,.55);
      padding: 24px;
      box-sizing: border-box;
    }
    .card {
      width: min(92vw, 420px);
      background: rgba(15,22,32,.95);
      border: 1px solid rgba(255,255,255,.14);
      border-radius: 16px;
      padding: 14px;
      box-shadow: 0 16px 48px rgba(0,0,0,.45);
    }
    .card h2 { margin: 0 0 8px; font-size: 16px; }
    .card p { margin: 0 0 12px; font-size: 13px; opacity: .9; line-height: 1.45; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>贪吃蛇</h1>
    <p class="sub">手机：滑动改变方向（更灵敏）/ 或用下面按钮（支持按住连发）。键盘：方向键或 WASD。点击「开始/暂停」。</p>

    <div class="panel">
      <canvas id="c" width="420" height="420" aria-label="snake game"></canvas>
    </div>

    <div class="bar">
      <div class="pill">分数：<span id="score">0</span></div>
      <div class="pill">最高：<span id="best">0</span></div>
      <div class="pill">速度：<span id="speed">1.0x</span></div>
      <button id="toggle">开始</button>
      <button id="restart">重开</button>
    </div>

    <div class="controls" aria-label="touch controls">
      <div class="spacer">.</div>
      <button data-dir="U">↑</button>
      <div class="spacer">.</div>
      <button data-dir="L">←</button>
      <button data-dir="D">↓</button>
      <button data-dir="R">→</button>
    </div>

    <div class="footer">提示：连续吃到食物会逐步加速。撞墙/撞到自己结束。</div>
  </div>

  <div class="overlay" id="over">
    <div class="card">
      <h2>游戏结束</h2>
      <p>点击「重开」再来一局。</p>
      <button id="closeOver">知道了</button>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const scoreEl = document.getElementById('score');
  const bestEl = document.getElementById('best');
  const speedEl = document.getElementById('speed');
  const toggleBtn = document.getElementById('toggle');
  const restartBtn = document.getElementById('restart');
  const overlay = document.getElementById('over');
  const closeOverBtn = document.getElementById('closeOver');

  const GRID = 21; // 21x21
  const CELL = canvas.width / GRID;

  const KEY = 'snake_best_v1';
  let best = Number(localStorage.getItem(KEY) || 0);
  bestEl.textContent = best;

  let running = false;
  let dead = false;

  let snake, dir, nextDir, food, score, tickMs, lastTick;

  function reset() {
    snake = [
      {x: 10, y: 11},
      {x: 10, y: 12},
      {x: 10, y: 13},
    ];
    dir = {x: 0, y: -1};
    nextDir = dir;
    score = 0;
    tickMs = 140;
    lastTick = 0;
    dead = false;
    placeFood();
    scoreEl.textContent = score;
    updateSpeedLabel();
    overlay.style.display = 'none';
  }

  function updateSpeedLabel() {
    const base = 140;
    const mul = (base / tickMs);
    speedEl.textContent = mul.toFixed(1) + 'x';
  }

  function randInt(n) { return Math.floor(Math.random() * n); }

  function placeFood() {
    while (true) {
      const f = {x: randInt(GRID), y: randInt(GRID)};
      if (!snake.some(s => s.x === f.x && s.y === f.y)) {
        food = f;
        return;
      }
    }
  }

  // allow one buffered turn per tick for snappier control
  let turnQueued = false;
  let queuedDir = null;

  function setDir(dx, dy) {
    // prevent reverse against current direction
    if (dx === -dir.x && dy === -dir.y) return;

    // if already queued a turn this tick, keep the first queued
    if (turnQueued) return;

    // if player changes direction rapidly within a tick, buffer once
    // (and also prevent immediate reverse against nextDir)
    if (dx === -nextDir.x && dy === -nextDir.y) return;

    queuedDir = {x: dx, y: dy};
    turnQueued = true;
    nextDir = queuedDir;
  }

  function step() {
    // start of tick: consume queued turn (already reflected in nextDir)
    dir = nextDir;
    const head = snake[0];
    const newHead = {x: head.x + dir.x, y: head.y + dir.y};

    // wall
    if (newHead.x < 0 || newHead.x >= GRID || newHead.y < 0 || newHead.y >= GRID) {
      gameOver();
      return;
    }
    // self
    if (snake.some((s, i) => i !== 0 && s.x === newHead.x && s.y === newHead.y)) {
      gameOver();
      return;
    }

    snake.unshift(newHead);

    // end of tick: allow a new buffered turn for next tick
    turnQueued = false;
    queuedDir = null;

    if (newHead.x === food.x && newHead.y === food.y) {
      score += 1;
      scoreEl.textContent = score;
      if (score > best) {
        best = score;
        localStorage.setItem(KEY, String(best));
        bestEl.textContent = best;
      }
      // speed up slightly
      tickMs = Math.max(70, tickMs - 3);
      updateSpeedLabel();
      placeFood();
    } else {
      snake.pop();
    }
  }

  function gameOver() {
    dead = true;
    running = false;
    toggleBtn.textContent = '开始';
    overlay.style.display = 'grid';
  }

  function draw() {
    // background
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // grid subtle
    ctx.save();
    ctx.globalAlpha = 0.07;
    ctx.strokeStyle = '#ffffff';
    for (let i=1;i<GRID;i++) {
      ctx.beginPath();
      ctx.moveTo(i*CELL, 0);
      ctx.lineTo(i*CELL, canvas.height);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(0, i*CELL);
      ctx.lineTo(canvas.width, i*CELL);
      ctx.stroke();
    }
    ctx.restore();

    // food (glow)
    ctx.save();
    ctx.shadowColor = 'rgba(255,204,102,.55)';
    ctx.shadowBlur = 14;
    ctx.fillStyle = '#ffcc66';
    roundRect(food.x*CELL+2, food.y*CELL+2, CELL-4, CELL-4, 10);
    ctx.fill();
    ctx.restore();

    // snake (slight glow)
    for (let i=snake.length-1;i>=0;i--) {
      const s = snake[i];
      const isHead = i === 0;
      ctx.save();
      ctx.shadowBlur = isHead ? 16 : 10;
      ctx.shadowColor = isHead ? 'rgba(102,224,255,.40)' : 'rgba(102,255,178,.28)';
      ctx.fillStyle = isHead ? '#66e0ff' : '#66ffb2';
      roundRect(s.x*CELL+2, s.y*CELL+2, CELL-4, CELL-4, isHead ? 12 : 10);
      ctx.fill();
      ctx.restore();
    }

    if (!running && !dead) {
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,.35)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#e8eef5';
      ctx.font = '600 16px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('点击「开始」或按空格开始', canvas.width/2, canvas.height/2);
      ctx.restore();
    }
  }

  function roundRect(x, y, w, h, r) {
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function loop(ts) {
    if (running && !dead) {
      if (!lastTick) lastTick = ts;
      const dt = ts - lastTick;
      if (dt >= tickMs) {
        lastTick = ts;
        step();
      }
    }
    draw();
    requestAnimationFrame(loop);
  }

  // controls
  document.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') setDir(0,-1);
    if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') setDir(0,1);
    if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') setDir(-1,0);
    if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') setDir(1,0);
    if (e.key === ' ') {
      e.preventDefault();
      toggle();
    }
  }, {passive:false});

  function toggle() {
    if (dead) return;
    running = !running;
    toggleBtn.textContent = running ? '暂停' : '开始';
    if (running) overlay.style.display = 'none';
  }

  toggleBtn.addEventListener('click', toggle);
  restartBtn.addEventListener('click', () => {
    reset();
    running = true;
    toggleBtn.textContent = '暂停';
  });
  closeOverBtn.addEventListener('click', () => overlay.style.display = 'none');

  // touch swipe
  // touch swipe (more responsive): track move, lower threshold, lock one direction per gesture
  let touchStart = null;
  let touchLocked = false;
  const SWIPE_THRESHOLD = 10;

  canvas.addEventListener('touchstart', (e) => {
    const t = e.touches[0];
    touchStart = {x: t.clientX, y: t.clientY};
    touchLocked = false;
  }, {passive:true});

  canvas.addEventListener('touchmove', (e) => {
    if (!touchStart || touchLocked) return;
    const t = e.touches[0];
    const dx = t.clientX - touchStart.x;
    const dy = t.clientY - touchStart.y;
    const adx = Math.abs(dx), ady = Math.abs(dy);
    if (Math.max(adx, ady) < SWIPE_THRESHOLD) return;

    if (adx > ady) setDir(dx > 0 ? 1 : -1, 0);
    else setDir(0, dy > 0 ? 1 : -1);

    touchLocked = true;
    // prevent page scroll
    e.preventDefault();
  }, {passive:false});

  canvas.addEventListener('touchend', (e) => {
    if (!touchStart) return;
    // tap toggles
    if (!touchLocked) toggle();
    touchStart = null;
    touchLocked = false;
  }, {passive:true});

  // on-screen buttons: support press-and-hold repeat
  function bindHold(btn, fn) {
    let timer = null;
    let active = false;

    const start = (e) => {
      e.preventDefault?.();
      if (active) return;
      active = true;
      fn();
      timer = setInterval(fn, 70);
    };

    const end = () => {
      active = false;
      if (timer) clearInterval(timer);
      timer = null;
    };

    btn.addEventListener('pointerdown', start);
    btn.addEventListener('pointerup', end);
    btn.addEventListener('pointercancel', end);
    btn.addEventListener('pointerleave', end);
  }

  document.querySelectorAll('.controls button[data-dir]').forEach(btn => {
    const d = btn.getAttribute('data-dir');
    const fn = () => {
      if (d === 'U') setDir(0,-1);
      if (d === 'D') setDir(0,1);
      if (d === 'L') setDir(-1,0);
      if (d === 'R') setDir(1,0);
    };
    bindHold(btn, fn);
  });

  reset();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
